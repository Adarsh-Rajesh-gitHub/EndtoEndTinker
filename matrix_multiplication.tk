.code
;read in
	in r1, r0
; n^2
	mul r6, r1, r1
	add r19, r0, r6
; n-1 (for brgt-only loop guards)
	mov r23, r1
	subi r23, 1
; rowBytes = 8*n
	ld r25, 8
	mul r10, r25, r1
; element counter for input loops (1..n^2)
	ld r2, 1
; read A
	ld r5, 200000
:ReadA
	ld r24, :AfterReadA
	brgt r24, r2, r19
	in r3, r0
	mov (r5)(0), r3
	addi r5, 8
	addi r2, 1
	ld r24, :ReadA
	br r24
:AfterReadA
; read B into 300000
	ld r5, 300000
	ld r2, 1
:ReadB
	ld r24, :Execute
	brgt r24, r2, r19
	in r3, r0
	mov (r5)(0), r3
	addi r5, 8
	addi r2, 1
	ld r24, :ReadB
	br r24
; compute C = A*B into 400000
:Execute
	ld r12, 200000
	ld r13, 300000
	ld r5, 400000
	clr r22
	clr r21
	clr r20
:RowStart
	ld r24, :Output
	brgt r24, r22, r23
; else fall through to ColStart
:ColStart
	ld r24, :NextRow
	brgt r24, r21, r23
; else fall through to SetupElem
:SetupElem
; A_row_base = A + i*rowBytes
	mul r14, r22, r10
	add r14, r14, r12
; B_col_base = B + j*8
	ld r25, 8
	mul r25, r21, r25
	add r15, r13, r25
; sum = 0.0 (bits all zero)
	clr r6
; k = 0
	clr r20
:ElembyElem
	ld r24, :FinishElem
	brgt r24, r20, r23
:DoMul
; A_ptr = A_row_base + 8*k
	ld r25, 8
	mul r16, r20, r25
	add r16, r14, r16
	mov r7, (r16)(0)
; B_ptr = B_col_base + rowBytes*k
	mul r17, r20, r10
	add r17, r15, r17
	mov r8, (r17)(0)
; sum += A*B (double ops)
	mulf r9, r7, r8
	addf r6, r6, r9
; k++
	addi r20, 1
	ld r24, :ElembyElem
	br r24
:FinishElem
; store C[i][j]
	mov (r5)(0), r6
	addi r5, 8
; j++
	addi r21, 1
	ld r24, :ColStart
	br r24
:NextRow
; i++
	addi r22, 1
; j = 0
	clr r21
	ld r24, :RowStart
	br r24
:Output
	ld r5, 400000
	clr r2
	mov r18, r19
	subi r18, 1
	ld r27, 1
:OutLoop
	ld r24, :Done
	brgt r24, r2, r18
	mov r26, (r5)(0)
	out r27, r26
	addi r5, 8
	addi r2, 1
	ld r24, :OutLoop
	br r24
:Done
	halt